---
title: JVM读书笔记之第十章
tags:
  - Java
categories:
  - 读书笔记
date: 2018-08-05 13:36:11
---

# 早期编译器优化

## 概述

- 前端编译器：把java文件编译成class文件
- JIT编译器（just in time compiler）：把字节码转变成机器码的过程
- AOT编译器（ahead of time compiler）：直接把java文件编译成本地机器码

## Javac编译器

从Sun Javac的代码来看，编译过程大致可以分为3个过程，

1. 解析与填充符号表过程
2. 插入式注解处理器的注解处理过程
3. 分析与字节码生成过程

### 解析与填充符号表过程

1. 词法、语法分析

   词法分析是将源代码的字符流转变为标记（Token）集合，单个字符是程序编写过程的最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、运算符都可以成为标记。

   语法分析是根据token序列构造抽象语法书的过程，抽象语法树（Abstract Syntax Tree，AST）是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构（Construct），例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。经历过这个步骤之后，编译器就基本不会再对源码文件进行操作了，后续的操作都建立在AST之上。

2. 填充符号表

   符号表（Symbol Table）是由一组符号地址和符号信息构成的表格。在语法分析中，符号表所登记的内容将用于语义检查（如检查一个名字的使用和原先的说明是否一致）和产生中间代码。在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据。



### 注解处理器

注解与普通的java代码一样，是在运行期间发挥作用的。略过。



### 语义分析与字节码生成

上面生成的AST可以表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查等。

在Javac的编译过程中，语义分析过程分为标注检查以及数据及控制流分析两个步骤。

- 标注检查

  包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配、常量折叠等。如`int a = 1 + 2`，语法树上能看到字面量1、2以及操作符“+”，但经过常量折叠之后会被折叠成字面量3。由于编译期间进行了常量折叠，所以在代码里面定义“a=1+2”比起直接定义“a=3”，并不会增加程序运行期间的运算量。

- 数据及控制流分析

  是对程序上下文逻辑更进一步的验证。可以检查出如局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受检查异常都被正确处理等问题。该阶段与类加载时的数据及控制流分析的目的基本上是一致的，但校验范围有所分别，有一些校验项只有在编译期或运行期才能进行。例如：

  ```java
  // 方法一带有final修饰
  public void foo(final int arg) {
      final int var = 0;
  }
  
  // 方法二没有final修饰
  public void foo(int arg) {
      int var = 0;
  }
  ```

  这两段代码编译出来的class文件没有任何区别，因为局部变量与字段（实例变量、类变量）有区别，它在常量池中没有CONSTANT_Fieldref_info的符号引用，自然就没有访问标志（Access_Flags）的信息，甚至可能连名称都不会保留下来（取决于编译时的选项），自然在class文件中不可能知道一个局部变量是否声明为final。因此将局部变量声明为final，对运行期是没有影响的，变量的不变形仅仅由编译器在编译期间保障。

- 解语法糖

  java中常用的语法糖主要是泛型、变长参数、自动装箱/拆箱，虚拟机运行时不支持这些语法，它们在编译期间还原回简单的基础语法结构。这个过程叫做解语法糖

- 字节码生成

  字节码生成是Javac编译过程的最后一个阶段。字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。

