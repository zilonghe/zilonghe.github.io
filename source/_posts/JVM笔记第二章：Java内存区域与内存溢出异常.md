---
title: JVM读书笔记之第二章
tags:
  - Java
categories:
  - 读书笔记
date: 2018-6-26 10:59:04
---
# Java内存区域与内存溢出异常

## 运行时数据区域

- 程序计数器：当前线程执行的字节码的行号指示器，线程私有，若线程正在执行的是java方法，则记录的是正在执行的虚拟机字节码指令的地址；若是Native本地方法，这个计数器值为空。该内存区域没有规定任何outOfMemoryError（OOM）的区域。
- Java虚拟机栈：每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，对应一个栈帧在虚拟机栈中入栈到出栈的过程。线程私有。可能抛出StackOverflowError和OOM。
  - 局部变量表：存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用、returnAddress类型。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变。
- 本地方法栈：与虚拟机栈相似，区别是本地方法栈为虚拟机使用的native方法服务。可能抛出StackOverflowError和OOM。
- 堆：存放对象实例，几乎所有对象实例都在这里分配内存。所有线程共享。在虚拟机启动时创建。JAVA堆是垃圾收集器管理的主要区域。可能会抛出OOM。
- 方法区：所有线程共享的区域。用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器（JIT）编译后的代码等数据。该区域的内存回收目标主要是针对常量池的回收和对类型的卸载。可能抛出OOM。
  - 运行时常量池：方法区的一部分。Class文件中除了有类的版本信息、字段、方法、接口等描述信息之外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分将在类加载后进入方法区的运行时常量池中存放。动态性，运行期间也可能将新的常量放入池内，如String的intern()方法。可能抛出OOM。
- 直接内存：并不是运行时数据区的一部分，JDK1.4新加入了NIO类，引入了一种基于通道channel和缓冲区buffer的io方式，可以使用native函数库直接分配堆外内存，然后通过存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。（Netty）。可能抛出OOM。
<!-- more -->
## 对象的创建

这里讨论的是普通对象的创建，不包括数组和class对象等的过程。

1. 虚拟机遇到一条new指令，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过（ClassLoader）。若没有，则必须先执行相应的类加载过程（第7章）。
2. 为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定。有两种分配方式，用哪种方式由内存空间是否规整决定，而内存空间是否规则又由GC是否带有压缩功能决定：
   1. 指针碰撞（Bump the Pointer）：假设Java堆中内存是绝对规整的，所有用过的内存放在一边，空闲的内存放在另外一边，中间放一个指针作为分界点的指示器，那分配内存就仅仅是把那个指针向空闲空间那边挪到一段与对象大小相等的距离。
   2. 空间列表（Free List）：如果java堆中的内存不是规整的，已使用的内存和空闲的内存互相交错，虚拟机必须维护一个列表，记录上那些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。
3. 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），保证了对象的实例字段在java代码中可以不赋值就直接使用。
4. 虚拟机对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存在对象的对象头之中。
5. 从虚拟机的视角来看，一个新的对象已经产生，但从java程序的视角来看，对象创建才刚刚开始——`<init>`方法还没有执行，所有的字段都还是零。所以执行new指令后，会执行`<init>`方法，把对象按照程序员的意愿进行初始化，一个真正可用的对象才算完全产生出来。

## 对象的内存布局

- 对象头Header：
  - 第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，官方称为Mark Word。
  - 另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个Java数组，那在对象头中还必须要有一块用于记录数据长度的数据。
- 实例数据instance data：对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的还是在子类中定义的，都需要记录起来。该部分的分配策略是相同宽度的字段总是被分配在一起，在这个前提下，在父类中定义的变量会出现在子类的之前。
- 对齐填充padding：非必然存在，占位符作用。对象大小必须是8字节的整数倍，对象头部分正好是8字节的倍数，当对象实例数据部分没有对齐，就需要对齐填充补齐。

## 对象的访问定位

java程序需要通过栈上的reference数据来操作堆上的具体对象。有两种访问方式：

1. 句柄访问：java堆会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
2. 直接指针访问：reference中存储的直接就是对象地址。

两种方式对比：

​	使用句柄的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（GC中）时只会改变句柄中的实例数据指针，而reference本身不需要修改。

​	使用指针访问方式的最大好处就是速度更快，节省了一次指针定位的时间开销。Sun HotSpot使用的是这种方式。