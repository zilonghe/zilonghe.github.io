# GO语言实战note

## 第二章

- 程序里所有的 init 方法都会在 main 函数启动前被调用

- 导入的路径前面有一个下划线，这个技术是为了让 Go 语言对包做初始化操作，但是并不使用包里的标识符。为了让程序的 可读性更强，Go 编译器不允许声明导入某个包却不使用。这种方法可以让编译器在导入未被引用的包时不报 错，而且依旧会定位到包内的 init 函数。

- 在 Go 语言里，标识符要么从包里公开，要么不从包里公开。当代码导入了一个包时，程序 可以直接访问这个包中任意一个公开的标识符。这些标识符以大写字母开头。以小写字母开头的 标识符是不公开的，不能被其他包中的代码直接访问。

- 如果需要声明初始值为零值 的变量，应该使用 var 关键字声明变量；如果提供确切的非零值初始化变量或者使用函数返回 值创建变量，应该使用简化变量声明运算符。

- 使用 for range 迭代切片时，每次迭代会返回两个值。第一个值是迭代的元素在切 片里的索引位置，第二个值是元素值的一个**副本**。

- 在 Go 语言中，所有的变量 都以值的方式传递。因为指针变量的值是所指向的内存地址，在函数间传递指针变量，是在传递 这个地址值，所以依旧被看作以值的方式在传递。

- `a[x]` is shorthand for `(*a)[x]`

- ```go
  对于struct类型，指向struct的指针p，p.Name 等价于 (*p).Name，go的编译器帮做了这一步寻址的步骤
  testpointer := &MyStruct{Name: "zilong", Age: "11"}
  fmt.Println(testpointer.Name) // zilong
  fmt.Println((*testpointer).Name) // zilong
  ```

- 关键字 defer 会安排随后的函数调用在函数返回时才执行。在使用完文件后，需要主动关 闭文件。使用关键字 defer 来安排调用 Close 方法，可以保证这个函数一定会被调用。哪怕函 数意外崩溃终止，也能保证关键字 defer 安排调用的函数会被执行。关键字 defer 可以缩短打 开文件和关闭文件之间间隔的代码行数，有助提高代码可读性，减少错误。

- 命名接口的时候，也需要遵守 Go 语言的命名惯例。如果接口类型只包含一个方法，那么这 个类型的名字以 er 结尾。我们的例子里就是这么做的，所以这个接口的名字叫作 Matcher。如 果接口类型内部声明了多个方法，其名字需要与其行为关联。

- 如果声明函数的时候带有接收者，则意味着声明了一个方法。这个方法会和指定的接收者的 类型绑在一起。

- 无论我们是使用接收者类型的值来调用这个方，还是使用接收者类型值的指针来调用这个 方法，编译器都会正确地引用或者解引用对应的值，作为接收者传递给 Search 方法

  ```go
  // 方法声明为使用 defaultMatcher 类型的值作为接收者
  func (m defaultMatcher) Search(feed *Feed, searchTerm string)
  // 声明一个指向 defaultMatcher 类型值的指针
  dm := new(defaultMatch)
  // 编译器会解开 dm 指针的引用，使用对应的值调用方法
  dm.Search(feed, "test")
  // 方法声明为使用指向 defaultMatcher 类型值的指针作为接收者
  func (m *defaultMatcher) Search(feed *Feed, searchTerm string)
  // 声明一个 defaultMatcher 类型的值
  var dm defaultMatch
  // 编译器会自动生成指针引用 dm 值，使用指针调用方法
  dm.Search(feed, "test")
  ```

- 使用指针作为接收者声明的方法，只能在接口类型的值是一个指针的时 候被调用。使用值作为接收者声明的方法，在接口类型的值为值或者指针时，都可以被调用。

  ```go
  // 方法声明为使用指向 defaultMatcher 类型值的指针作为接收者
  func (m *defaultMatcher) Search(feed *Feed, searchTerm string)
  // 通过 interface 类型的值来调用方法
  var dm defaultMatcher
  var matcher Matcher = dm // 将值赋值给接口类型
  matcher.Search(feed, "test") // 使用值来调用接口方法
  > go build
  cannot use dm (type defaultMatcher) as type Matcher in assignment
  // 方法声明为使用 defaultMatcher 类型的值作为接收者
  func (m defaultMatcher) Search(feed *Feed, searchTerm string)
  // 通过 interface 类型的值来调用方法
  var dm defaultMatcher
  var matcher Matcher = &dm // 将指针赋值给接口类型
  matcher.Search(feed, "test") // 使用指针来调用接口方法
  > go build
  Build Successful
  ```

## 第三章

- 如果路径包含 URL，可以使用 Go 工具链从 DVCS 获取包，并把包的源代码保存在 GOPATH 指向的路径里与 URL 匹配的目录里。这个获取过程 使用 go get 命令完成。go get 将获取任意指定的 URL 的包，或者一个已经导入的包所依赖的其 他包。
- go run 命令会先构建 wordcount.go 里包含的程序，然后执行构建后的程序。
- go vet 工具不能让开发者避免严重的逻辑错误，或者避免编写充满小错的代码。不过，正 像刚才的实例中展示的那样，这个工具可以很好地捕获一部分常见错误。每次对代码先执行 go vet 再将其签入源代码库是一个很好的习惯。

## 第四章

- 如果在[]运算符里指定了一个值，那么创建的就是数组而不是切片。只有不指定值 的时候，才会创建切片

```go
// 创建有 3 个元素的整型数组
array := [3]int{10, 20, 30}
// 创建长度和容量都是 3 的整型切片
slice := []int{10, 20, 30}
```

- 需要记住的是，现在两个切片共享同一个底层数组。如果一个切片修改了该底层数组的共享 部分，另一个切片也能感知到

```go
// 创建一个整型切片
// 其长度和容量都是 5 个元素
slice := []int{10, 20, 30, 40, 50}
// 创建一个新切片
// 其长度是 2 个元素，容量是 4 个元素
newSlice := slice[1:3]
// 修改 newSlice 索引为 1 的元素
// 同时也修改了原来的 slice 的索引为 2 的元素
newSlice[1] = 35
```

- 因为 newSlice 在底层数组里还有额外的容量可用，append 操作将可用的元素合并到切片 的长度，并对其进行赋值。由于和原始的 slice 共享同一个底层数组，slice 中索引为 3 的元 素的值也被改动了。在创建切片时设置切片的容量和长度一样，就可以强制让新切片的第一个 append 操作 创建新的底层数组，与原有的底层数组分离。新切片与原有的底层数组分离后，可以安全地进行 后续修改。

```go
// 创建一个整型切片
// 其长度和容量都是 5 个元素
slice := []int{10, 20, 30, 40, 50}
// 创建一个新切片
// 其长度为 2 个元素，容量为 4 个元素
newSlice := slice[1:3]
// 使用原有的容量来分配一个新元素
// 将新元素赋值为 60
newSlice = append(newSlice, 60)
```

- 函数 append 会智能地处理底层数组的容量增长。在切片的容量小于 1000 个元素时，总是 会成倍地增加容量。一旦元素个数超过 1000，容量的增长因子会设为 1.25，也就是会每次增加 25% 的容量。
- range迭代返回的变量是一个迭代过程中根据切片依次赋值的新变量，所以 value 的地址总 是相同的。要想获取每个元素的地址，可以使用切片变量和索引值。

```go
// 创建一个整型切片
// 其长度和容量都是 4 个元素
slice := []int{10, 20, 30, 40}
// 迭代每个元素，并显示值和地址
for index, value := range slice {
fmt.Printf("Value: %d Value-Addr: %X ElemAddr: %X\n",
value, &value, &slice[index])
} 
Output:
Value: 10 Value-Addr: 10500168 ElemAddr: 1052E100
Value: 20 Value-Addr: 10500168 ElemAddr: 1052E104
Value: 30 Value-Addr: 10500168 ElemAddr: 1052E108
Value: 40 Value-Addr: 10500168 ElemAddr: 1052E10C
```

- 在函数间传递映射并不会制造出该映射的一个副本。实际上，当传递映射给一个函数，并对 这个映射做了修改时，所有对这个映射的引用都会察觉到这个修改

## 第五章

- 如果使用值接收者声明方法，调用时会使 用这个值的一个副本来执行；当调用使用指针接收者声明的 方法时，这个方法会共享调用方法时接收者所指向的值；总结一下，值接收者使用 值的副本来调用方法，而指针接受者使用实际值来调用方法。

- 方法集规则，因为不是总能获取一个值的地址，所以值的方法集只包括了使用值接收者实现的方法。
```
  Values Methods Receivers
  -----------------------------------------------
   T (t T)
  *T (t T) and (t *T)
   Methods Receivers Values
  -----------------------------------------------
  (t T) T and *T
```

- 嵌入类型是将已有的类型直接声明在新的结构类型里。被嵌入的类型被称为新的外部类型的内部类型。

- 要嵌入一个类型，只需要声明这个类型的名字就可以了

## 第六章

- go build -race // 用竞争检测器标志来编译程序
- runtime.Gosched() : 当前 goroutine 让出cpu时间片，允许别的 goroutines 执行，不会阻塞当前 goroutine

- 当通道关闭后，goroutine 依旧可以从通道接收数据， 但是不能再向通道里发送数据。能够从已经关闭的通道接收数据这一点非常重要，因为这允许通 道关闭后依旧能取出其中缓冲的全部值，而不会有数据丢失。从一个已经关闭且没有数据的通道 里获取数据，总会立刻返回，并返回一个通道类型的零值。如果在获取通道时还加入了可选的标 志，就能得到通道的状态信息。
- 一般来说，select 语句在没有任 何要接收的数据时会阻塞，不过有了第 98 行的 default 分支就不会阻塞了。default 分支会 将接收 interrupt 通道的阻塞调用转变为非阻塞的。如果 interrupt 通道有中断信号需要接 收，就会接收并处理这个中断。如果没有需要接收的信号，就会执行 default 分支。

## 第九章

- Go 语言的测试工具只会认为以_test.go 结尾的文件是测试文件。如果没有遵从这个约定，在包里 运行 go test 的时候就可能会报告没有测试文件。一旦测试工具找到了测试文件，就会查找里 面的测试函数并执行。
- 一个测试函数 必须是公开的函数，并且以 Test 单词开头。不但函数名字要以 Test 开头，而且函数的签名必 须接收一个指向 testing.T 类型的指针，并且不返回任何值。如果没有遵守这些约定，测试框 架就不会认为这个函数是一个测试函数，也不会让测试工具去执行它。
- 基准测试函数必须以 Benchmark 开头，接受一个指向 testing.B 类型的指针作为唯一参数。